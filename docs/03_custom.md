# Customisation

Our library provides different ways to resolve non-usual cases. Here is list and
ways to do it

## Validators

If you need to set up custom validators for your Route, you can do it next way

```php
declare(strict_types=1);

namespace Example\Validation;

use Assert\Assertion;
use BadMethodCallException;
use ESB\Exception\ValidationException;
use ESB\Validation\ValidatorInterface;

class AssertValidator implements ValidatorInterface
{
    public function validate(mixed $value, string $propertyPath, array $params = []) : void
    {
        $params['propertyPath'] = $propertyPath;
        $assertName             = $params['assertName'] ?? '';
        unset($params['assertName']);
        try {
            Assertion::{$assertName}($value, ...$params);
        } catch (BadMethodCallException $e) {
            throw new ValidationException($e->getMessage(), $propertyPath);
        }
    }
}
```

What needs to do - implement `ValidatorInterface` and `validate()` method. Available params:
- value - income value for validation
- propertyPath - property path, generated by framework. Can be used in exception.
- params - any array key-value data. Passed from Route entity

And set it in your `ContainerConfig` class with `validators` key

```php
    'validators' => [
        'oneOf'           => OneOf::class,
        'assertValidator' => AssertValidator::class,
    ],
```

## Formatters

If you need to use non-built-in functions from twig, and some other ways to
transform data, you can register _Formatter_.

```php
declare(strict_types=1);

namespace Example\Formatter;

class CustomFormatter
{
    /** example of injecting some service, which could get data from external sources, like a database or whatever */
    public function __construct()
    {
    }

    /** could be some complicated logic to fetch required data  */
    public function __invoke(string $key) : string
    {
        return "text_from_formatter + key $key from template";
    }
}
```

In your `ContainerConfig` use `formatters` key

```php
    'formatters' => [
        'customFormatter' => CustomFormatter::class,
    ],
```

And after that you can use it in twig template!

```twig
{
    "some_data": "{{ customFormatter(body.id) }}"
}
```

## Runner(Splitter)

If you need to split message to pieces and pass to different systems in one process, or other customization, you can set
Runner to Route.

ContainerConfig:
```php
    'runner' => [
        'my-runner' => MyCustomRunner::class,
    ],
```

RouteConfig:
```php 
    "customRunner": "my-runner",
```
Example:
```php
    class MyCustomRunner implements CoreRunnerInterface
    {
        public function __construct(private readonly Core $core)
        {
        }

        public function runCore(ProcessingData $data, Route $route) : ProcessingData
        {
            foreach ($this->normalizeMessage($data) as $groupedMessage) {
                $runnerData = $this->core->run($groupedMessage, $route);
                /** if got failed, return fail response */
                if (! $runnerData->targetResponse()->isSuccess) {
                    return $runnerData;
                }
            }

            return $data->withTargetResponse(
                new TargetResponse(['code' => 200, 'message' => 'success'], 0)
            );
        }

        /** @psalm-return ProcessingData[] */
        private function normalizeMessage(ProcessingData $processingData) : array
        {
            // will split original message by some rules
        }
    }
```